
   
   
      
         
            Getting <ENAMEX TYPE="WORK_OF_ART">Buggy Wit It</ENAMEX> 

            There I was, <TIMEX TYPE="TIME">late one night</TIMEX>
in the <ENAMEX TYPE="ORGANIZATION">Microsoft</ENAMEX> software <ENAMEX TYPE="FAC_DESC">factory</ENAMEX>, furiously exterminating some of the skankier
bugs from my areas of <ENAMEX TYPE="PRODUCT">Outlook 97</ENAMEX>, our e-mail program. My skill at writing
software, I believe, is God-given. My legendary success at squashing <ENAMEX TYPE="ANIMAL">bugs</ENAMEX>, I
believe, is the result of my tendency to write buggy code. So it was no
surprise when one of the <NUMEX TYPE="CARDINAL">dozens</NUMEX> of software <ENAMEX TYPE="PER_DESC">testers</ENAMEX> employed by the Outlook <NUMEX TYPE="CARDINAL">97</NUMEX>
<ENAMEX TYPE="ORGANIZATION">team</ENAMEX> sent me urgent e-mail. He had discovered a giant bug in my area and was
insistent I inspect it.

            The first
thing you do when a tester brings you a bug is reproduce it. In this case,
<ENAMEX TYPE="ORGANIZATION">reproduction</ENAMEX> would be easy. Step <NUMEX TYPE="CARDINAL">1</NUMEX>: Create an appointment in <ENAMEX TYPE="GPE">Outlook</ENAMEX>'s
calendar. Step <NUMEX TYPE="CARDINAL">2</NUMEX>: Add a conference <ENAMEX TYPE="FAC_DESC">room</ENAMEX> to the appointment. So far so good.
Step <NUMEX TYPE="CARDINAL">3</NUMEX>: Change the date of the appointment to <TIMEX TYPE="DATE">the year 4500</TIMEX>. Step <NUMEX TYPE="CARDINAL">4</NUMEX>: Switch to
the meeting planner page. Step <NUMEX TYPE="CARDINAL">5</NUMEX> ...

            Istopped reading the <ENAMEX TYPE="ORG_DESC">tester</ENAMEX>'s e-mail and wrote back.
Although it was a bad bug, I felt confident I could ignore it for, oh, <NUMEX TYPE="CARDINAL">2,000</NUMEX>
<TIMEX TYPE="DATE">years or so</TIMEX>. But <ENAMEX TYPE="PERSON">Shuman</ENAMEX>, the <ENAMEX TYPE="PER_DESC">crowds chant</ENAMEX>, doesn't that mean you willingly
shipped buggy software? That you deliberately added to the torment of <NUMEX TYPE="CARDINAL">millions</NUMEX>
of computer <ENAMEX TYPE="PER_DESC">users</ENAMEX> who can't get their software to work? Why shouldn't
Outlook 97 be able to handle <ENAMEX TYPE="PER_DESC">appointments</ENAMEX> in specified conference <ENAMEX TYPE="FAC_DESC">rooms</ENAMEX> in
future <ENAMEX TYPE="PER_DESC">millenniums</ENAMEX>?

            Well,
<ENAMEX TYPE="PER_DESC">folks</ENAMEX>, I've got news for you: Nothing is perfect, and software is no exception.
<TIMEX TYPE="DATE">Today</TIMEX>'s robust software products from <ENAMEX TYPE="ORGANIZATION">Microsoft</ENAMEX>, <ENAMEX TYPE="ORGANIZATION">Lotus</ENAMEX>, <ENAMEX TYPE="ORGANIZATION">Borland, Corel</ENAMEX>, and all
the rest are too damn complex to be perfect. How complex are they? <ENAMEX TYPE="ORGANIZATION">Microsoft</ENAMEX>'s
Windows <NUMEX TYPE="CARDINAL">95</NUMEX> operating system contains <NUMEX TYPE="CARDINAL">more than 10 million</NUMEX> lines of code, or
instructions. Compare that with the <NUMEX TYPE="CARDINAL">6 million</NUMEX> parts in a <ENAMEX TYPE="ORGANIZATION">Boeing</ENAMEX> <ENAMEX TYPE="PRODUCT">747</ENAMEX>, <NUMEX TYPE="CARDINAL">3 million</NUMEX>
of which are fasteners such as rivets. Fasteners are wonderful, but they don't
interact much with one another. The difficult thing about writing software is
that all <NUMEX TYPE="CARDINAL">10 million</NUMEX> parts of <ENAMEX TYPE="PRODUCT">Windows 95</ENAMEX> are tightly coupled. Pop a rivet on
your <TIMEX TYPE="DATE">747</TIMEX>, and you're still likely to make your destination. But bollix up <NUMEX TYPE="CARDINAL">one</NUMEX>
line of code in <ENAMEX TYPE="LAW">Windows 95</ENAMEX>, and <ENAMEX TYPE="PER_DESC">users</ENAMEX>' computer screens will turn screaming
<ENAMEX TYPE="ORGANIZATION">blue</ENAMEX> and crash.

            
What are bugs, anyway? And what makes them more
insidious than a few blown rivets? <ENAMEX TYPE="ANIMAL">Bugs</ENAMEX> are errors, somewhat analogous to typos
or factual errors in newspaper articles, but the difference is that a typo is
almost never enough to spoil an entire edition of a <ENAMEX TYPE="ORG_DESC">newspaper</ENAMEX>, whereas a tiny
error in a software program can scuttle it. Take <TIMEX TYPE="DATE">the year 2000</TIMEX> bug for example.
The <NUMEX TYPE="ORDINAL">Y2K</NUMEX> bug arises because past <ENAMEX TYPE="PER_DESC">programmers</ENAMEX> expressed <TIMEX TYPE="DATE">years</TIMEX> with <NUMEX TYPE="CARDINAL">two</NUMEX> digits
rather than <NUMEX TYPE="CARDINAL">four</NUMEX>, so that <TIMEX TYPE="DATE">the year 1915</TIMEX> is written as <NUMEX TYPE="CARDINAL">15</NUMEX>. Thus to the computer,
<TIMEX TYPE="DATE">the year 2015</TIMEX> looks the same as <TIMEX TYPE="DATE">the year 1915</TIMEX>. (<ENAMEX TYPE="ORGANIZATION">Click</ENAMEX> to find out why
programmers deliberately created <TIMEX TYPE="DATE">the Y2K</TIMEX> bug, and why that wasn't such a crazy
thing to do.) The <NUMEX TYPE="ORDINAL">Y2K</NUMEX> bug is a very bad bug; the <NUMEX TYPE="CARDINAL">one</NUMEX> tiny decision about how to
<ENAMEX TYPE="ORGANIZATION">express</ENAMEX> dates can bring a whole program to a screeching halt.

            Bugs fall
into <NUMEX TYPE="CARDINAL">two</NUMEX> major categories: crashing and functional. Crashing bugs are so
naughty that they cause programs to stop functioning. Usually, this results in
friendly warnings--such as "<ENAMEX TYPE="WORK_OF_ART">Illegal Operation" for Windows</ENAMEX> <ENAMEX TYPE="PER_DESC">users</ENAMEX> or the lovely
picture of a bomb for <ENAMEX TYPE="ORGANIZATION">Macintosh</ENAMEX> <ENAMEX TYPE="PER_DESC">users</ENAMEX>. The other type of bug is a functional
bug--e.g., <TIMEX TYPE="DATE">the Y2K</TIMEX> bug--which is subtler in nature. Functional bugs cause
programs to fail or to give erroneous results. The number of either kind of bug
is proportional to the size of the program.

            But, as <ENAMEX TYPE="ORGANIZATION">Shuman</ENAMEX> can tell you, it's easy to write bugs into
simple, short programs, like one designed to find a single word in a sentence.
Actually, it's not that simple an operation. You must write perfectly logical
statements in a language that the computer can understand. If you were to write
this program in C, a popular programming language, it would take <NUMEX TYPE="CARDINAL">three</NUMEX> lines of
code to tell the program to look at the beginning of the word and the beginning
of each sentence. Next, you'd instruct the computer to match each <ENAMEX TYPE="PER_DESC">character</ENAMEX> in
the word you are searching for to the corresponding <ENAMEX TYPE="PER_DESC">characters</ENAMEX> in the sentence.
If the letters are the same, you continue. This would take <NUMEX TYPE="CARDINAL">five</NUMEX> lines of code.
Then you would have to confirm you have gone through all the letters in the
word successfully. Chalk up <NUMEX TYPE="CARDINAL">two</NUMEX> more lines. Then you'd need to see if there are
any letters in the sentence left to compare. <NUMEX TYPE="CARDINAL">Two</NUMEX> lines of code. Lastly, you
would have to inform the <ENAMEX TYPE="PER_DESC">user</ENAMEX> of your program what happened. Another three
lines--<NUMEX TYPE="CARDINAL">15</NUMEX> lines of code to find one word! <ENAMEX TYPE="ORGANIZATION">Shuman</ENAMEX> is exhausted just thinking
about it, and he hasn't even started creating bugs! Dropping <NUMEX TYPE="CARDINAL">one</NUMEX> essential
instruction or writing the lines of code in the wrong order could spell
destruction for my little program. (For all the gory details on how I actually
wrote this program in C, click .)

            <ENAMEX TYPE="CONTACT_INFO">Civilians</ENAMEX>
assume software <ENAMEX TYPE="ORG_DESC">companies</ENAMEX> spend most of their time writing software. Wrong!
They spend most of their time testing software! After <ENAMEX TYPE="PER_DESC">developers</ENAMEX> write a
few lines of code, we test it for bugs and sit down with our <ENAMEX TYPE="PER_DESC">testers</ENAMEX> to imagine
all the ways the program will be used. Good <ENAMEX TYPE="PER_DESC">testers</ENAMEX> make gnarly demands on the
code, inventing disaster scenarios worthy of <ENAMEX TYPE="GPE">Hollywood</ENAMEX>. (My favorite tester
routinely yanked the power cord out of the computer during Outlook operations
to see how the program handled loss of power.) Testers run the software on
different PCs--how will it work on a <ENAMEX TYPE="ORGANIZATION">Hewlett Packard</ENAMEX> computer vs. a <ENAMEX TYPE="ORGANIZATION">Packard</ENAMEX>
<ENAMEX TYPE="ORGANIZATION">Bell</ENAMEX>? They print with old printers. They enter <NUMEX TYPE="CARDINAL">thousands</NUMEX> of lines of text into
small <ENAMEX TYPE="FAC_DESC">fields</ENAMEX>. <NUMEX TYPE="CARDINAL">One</NUMEX> tester placed most of the text of the <ENAMEX TYPE="PER_DESC">King</ENAMEX> <ENAMEX TYPE="PERSON">James Bible</ENAMEX> into
an e-mail message, sent it to himself, and then replied to the e-mail. Outlook
choked at this point, demanding a day of rest. God was watching. Here at

                  Slate
                we rarely tug on the power cord to test our code, but we do
test the site on a variety of browsers.

            
At the beginning of a software project, code is
buggy, because we're still getting different parts of the program to cooperate.
A line of code that tells the program how to print may clash with the code that
tells the program how to draw the screen. As <ENAMEX TYPE="PER_DESC">testers</ENAMEX> hunt bugs, <ENAMEX TYPE="PER_DESC">developers</ENAMEX>
conspire with the marketing <ENAMEX TYPE="ORG_DESC">department</ENAMEX> to add features to the product, which
breeds more potential bugs. Adding new features to a stable program can be
dangerous. <ENAMEX TYPE="PER_DESC">Developers</ENAMEX> can create bugs faster than <ENAMEX TYPE="PER_DESC">testers</ENAMEX> can capture them, and
<ENAMEX TYPE="PER_DESC">testers</ENAMEX> can capture them faster than <ENAMEX TYPE="PER_DESC">developers</ENAMEX> can kill them, so the only way
to finish a product is to stop adding features and start paying attention to
the bugs.

            
Preventing <ENAMEX TYPE="PER_DESC">developers</ENAMEX> from adding features is not as easy as it sounds. They
love to build things--not to fix things. <NUMEX TYPE="CARDINAL">One</NUMEX> way to deter them is to break
their <ENAMEX TYPE="PRODUCT_DESC">arms</ENAMEX> with a baseball bat. Given <TIMEX TYPE="TIME">infinite time</TIMEX>, <ENAMEX TYPE="PER_DESC">developers</ENAMEX> would prefer to
add feature upon feature and never release their product. But marketing people
are the worst offenders when it comes to wanting to add new features,
generating loud choruses of "NO" even from otherwise enthusiastic
<ENAMEX TYPE="PER_DESC">developers</ENAMEX>.

            Agood tester is like the <ENAMEX TYPE="PRODUCT">Roach Motel</ENAMEX>, corralling bugs and
ensnaring them. "Look what I caught!" the tester meows as he drops the vermin
on the <ENAMEX TYPE="ORG_DESC">developer</ENAMEX>'s doorstep. <ENAMEX TYPE="PER_DESC">Testers</ENAMEX> are as vain about finding bugs as I am
<NUMEX TYPE="CARDINAL">about</NUMEX> squashing them, hence the excessive pride of my <ENAMEX TYPE="PER_DESC">tester</ENAMEX> who uncovered the
<TIMEX TYPE="DATE">year 4500</TIMEX> bug.

            Having
found a bug, it's not easy to find what caused it. Where is the bad assumption
that got us into trouble? Some bugs are hell to track down. One crashing bug in
Outlook would reproduce only on a <ENAMEX TYPE="PRODUCT">Gateway</ENAMEX> computer equipped with a <ENAMEX TYPE="ORGANIZATION">Matrox</ENAMEX> video
<ENAMEX TYPE="PER_DESC">card</ENAMEX>. Eventually, we tracked the bug down to one single line of code that
failed because it assumed all graphics cards are created equal. They are
not.

            
Bug fixing is time consuming. <ENAMEX TYPE="PER_DESC">Developers</ENAMEX> must
review every line of code, one at a time. They often deploy programs called
"debuggers," which allow them to peer into the innards of the software as it
runs. As <ENAMEX TYPE="PER_DESC">developers</ENAMEX> kill the bugs, they incorporate the <ENAMEX TYPE="SUBSTANCE">solutions</ENAMEX> into a daily
"build" of the program and test the build to make certain the solutions don't
cause additional bugs. Outlook <NUMEX TYPE="CARDINAL">97</NUMEX> went through <NUMEX TYPE="CARDINAL">several thousand</NUMEX> builds before
it was released, each build bringing us infinitesimally closer to
perfection.

            As we
approach perfection, though, the law of diminishing returns kicks in. Are the
existing bugs fatal defects, or can we live with them? We <ENAMEX TYPE="PER_DESC">developers</ENAMEX> have a
name for bugs we can live with: "known issues." By the time Outlook <TIMEX TYPE="DATE">97</TIMEX> was
released in <TIMEX TYPE="DATE">November 1997</TIMEX>, I suspect I was intimate with every one of its known
issues. I also suspect that <NUMEX TYPE="PERCENT">99 percent</NUMEX> of all bugs reported by <ENAMEX TYPE="PER_DESC">users</ENAMEX> to
software <ENAMEX TYPE="ORG_DESC">companies</ENAMEX> have already been noted and prioritized for fixing by some
late-night <ENAMEX TYPE="PER_DESC">team</ENAMEX> of code <ENAMEX TYPE="PER_DESC">warriors</ENAMEX>.

            The worst bug is a "show stopper" bug, the bug that will
croak the entire program. When a show stopper is discovered, we drop everything
and find a fix. But we make the absolutely smallest necessary change to kill
the bug so that the other parts of the system can continue to work, oblivious
to the chaos around them.

            <ENAMEX TYPE="PER_DESC">Developers</ENAMEX>
seek a balance between "it's done" and "it's perfect" when writing software.
But it's difficult to know when to stop. You are always <TIMEX TYPE="TIME">only a few late nights</TIMEX>
away from perfection. Where refining a <NUMEX TYPE="CARDINAL">747</NUMEX> is, shall we say, somewhat involved,
software writing is powered on caffeine and little more. In fact, one
enterprising young <ENAMEX TYPE="PER_DESC">developer</ENAMEX> strung out on <ENAMEX TYPE="LOCATION">Mountain Dew</ENAMEX> eventually fixed the
<TIMEX TYPE="DATE">year 4500</TIMEX> bug in <ENAMEX TYPE="LAW">Outlook 98</ENAMEX>, making it safe for everyone making appointments in
the next several millenniums.

            
               If you
missed our links in the article, click to read about why <ENAMEX TYPE="PER_DESC">programmers</ENAMEX> created
the <NUMEX TYPE="ORDINAL">Y2K</NUMEX> bug and for a "simple" program in <ENAMEX TYPE="ORGANIZATION">C.</ENAMEX>
            

         
      
   
